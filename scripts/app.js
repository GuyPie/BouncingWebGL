// Generated by CoffeeScript 1.6.3
(function() {
  var $container, ASPECT, FAR, HEIGHT, NEAR, ORIGIN, VIEW_ANGLE, WIDTH, ambient, animate, ball, ballDirection, ballGeometry, ballRadius, ballsContainer, camera, clock, cubemap, cylinder, cylinderGeometry, i, material, mousePosition, onMouseClick, onMouseMove, pointLight, reflectionMaterial, reflectionMaterialBlue, reflectionMaterialGreen, reflectionMaterialRed, render, renderer, rings, scene, segments, shader, skybox, urls, _i;

  WIDTH = window.innerWidth;

  HEIGHT = window.innerHeight;

  VIEW_ANGLE = 45;

  ASPECT = WIDTH / HEIGHT;

  NEAR = 1;

  FAR = 1500;

  ORIGIN = new THREE.Vector3;

  clock = new THREE.Clock;

  $container = $('#container');

  renderer = new THREE.WebGLRenderer({
    antialias: true
  });

  renderer.autoClear = false;

  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  scene = new THREE.Scene;

  renderer.setSize(WIDTH, HEIGHT);

  $container.append(renderer.domElement);

  ballRadius = 5;

  segments = 16;

  rings = 16;

  ballGeometry = new THREE.SphereGeometry(ballRadius, segments, rings);

  ballsContainer = new THREE.Object3D;

  ballsContainer.position.set(-100, 100, 40);

  camera.position.set(0, 0, 300);

  scene.add(camera);

  urls = ['images/santa_maria/posx.jpg', 'images/santa_maria/negx.jpg', 'images/santa_maria/posy.jpg', 'images/santa_maria/negy.jpg', 'images/santa_maria/posz.jpg', 'images/santa_maria/negz.jpg'];

  cubemap = THREE.ImageUtils.loadTextureCube(urls);

  cubemap.format = THREE.RGBFormat;

  shader = THREE.ShaderLib["cube"];

  shader.uniforms["tCube"].normal = cubemap;

  material = new THREE.ShaderMaterial({
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: shader.uniforms,
    depthWrite: false,
    side: THREE.BackSide
  });

  skybox = new THREE.Mesh(new THREE.CubeGeometry(1000, 1000, 1000), material);

  skybox.flipSided = true;

  scene.add(skybox);

  ambient = new THREE.AmbientLight(0xffffff);

  scene.add(ambient);

  pointLight = new THREE.PointLight(0xffffff, 2);

  scene.add(pointLight);

  reflectionMaterialRed = new THREE.MeshLambertMaterial({
    color: 0xff0000,
    envMap: cubemap
  });

  reflectionMaterialGreen = new THREE.MeshLambertMaterial({
    color: 0x00ff00,
    envMap: cubemap
  });

  reflectionMaterialBlue = new THREE.MeshLambertMaterial({
    color: 0x0000ff,
    envMap: cubemap
  });

  for (i = _i = 0; _i < 80; i = _i += 1) {
    reflectionMaterial = [reflectionMaterialRed, reflectionMaterialGreen, reflectionMaterialBlue][Math.floor(Math.random() * 3)];
    ball = new THREE.Mesh(ballGeometry, reflectionMaterial);
    ball.position.x = i % 20 * ballRadius * 2;
    ball.position.y = -Math.floor(i / 20) * ballRadius * 2;
    ballsContainer.add(ball);
  }

  scene.add(ballsContainer);

  cylinderGeometry = new THREE.CylinderGeometry(5, 15, 40, 32);

  cylinderGeometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 2));

  cylinder = new THREE.Mesh(cylinderGeometry, reflectionMaterial);

  cylinder.position.set(0, -80, 40);

  scene.add(cylinder);

  mousePosition = new THREE.Vector3(0, 0, 40);

  ballDirection = null;

  ball = null;

  onMouseMove = function(event) {
    return mousePosition.x = event.clientX - WIDTH / 2;
  };

  onMouseClick = function(event) {
    scene.remove(ball);
    reflectionMaterial = [reflectionMaterialRed, reflectionMaterialGreen, reflectionMaterialBlue][Math.floor(Math.random() * 3)];
    ball = new THREE.Mesh(ballGeometry, reflectionMaterial);
    ballDirection = cylinder.rotation.y;
    ball.position.set(25 * Math.sin(ballDirection), 25 * Math.cos(ballDirection) - 80, 40);
    return scene.add(ball);
  };

  document.addEventListener('mousemove', onMouseMove, false);

  document.addEventListener('mousedown', onMouseClick, false);

  animate = function() {
    window.requestAnimationFrame(animate);
    return render();
  };

  render = function() {
    var delta, time;
    delta = clock.getDelta();
    time = clock.getElapsedTime();
    ballsContainer.position.y -= delta;
    cylinder.lookAt(mousePosition);
    if (ballDirection) {
      ball.position.x += Math.sin(ballDirection) * delta * 100;
      ball.position.y += Math.cos(ballDirection) * delta * 100;
    }
    return renderer.render(scene, camera);
  };

  animate();

}).call(this);
